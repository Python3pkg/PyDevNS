import os
import sys
import socket
import logging
import functools
import subprocess

from . import config
from . import __version__
from contextlib import contextmanager


logger = logging.getLogger(__name__)


def interruptable(func):
    @functools.wraps(func)
    def decorator(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except KeyboardInterrupt:
            logging.info("User pressed Control+C, shutting down")

    return decorator


class DevNS(object):
    def __init__(self):
        print "PyDevNS v{}".format(__version__)

    def _choose_address(self, addresses):
        logger.debug("Selecting the best IP from candidates %r", addresses)
        possible = []
        for address in addresses:
            try:
                ip = [int(p) for p in address.split(".")]
                assert ip[0] in (192, 172, 127, 10)
                assert ip[3] < 255
                if ip[0] == 192:
                    assert ip[1] == 168
                if ip[0] == 172:
                    assert ip[1] > 15
                    assert ip[1] < 32
                possible.append(ip)
                logger.debug("Considering %s", address)
            except:
                logger.debug("Skipping %s", address)
        try:
            address = "{}.{}.{}.{}".format(
                *sorted(
                    possible,
                    key=lambda p: "{}-{}".format(p[-1], 0 if p[0] == 127 else 1)
                )[-1]
            )
            logger.debug("Selected IP address %s", address)
            return address
        except:
            logger.warning("Found no suitable IP addresses in %r", addresses)

    def _get_address_by_hostname(self):
        logger.debug("Attempting to determine response IP from hostname")
        hostname = socket.getfqdn()
        logger.debug("Resolving hostname %r", hostname)
        try:
            return self._choose_address(socket.gethostbyname_ex(hostname)[2])
        except Exception as e:
            logger.warning("Unable to resolve %r: %s", hostname, e)

    def _get_address_by_ifconfig(self):
        logger.debug("Attempting to determine response IP from ifconfig")
        addresses = []
        for line in subprocess.check_output(("ifconfig")).split("\n"):
            try:
                parts = line.strip().split(" ")
                assert parts[0] == "inet"
                address = parts[1].split(":")[-1]
                addresses.append(address)
            except:
                continue
        return self._choose_address(addresses)

    @property
    def address(self):
        return self._address

    @address.setter
    def address(self, address):
        address = address or self._get_address_by_ifconfig()
        address = address or self._get_address_by_hostname()
        if not address:
            logger.critical(
                "Could not determine a suitable response IP address. Please "
                "specify one."
            )
            sys.exit(1)
        self._address = address

    @contextmanager
    def _open_socket(self):
        logger.debug("Opening socket")
        connection = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        logger.debug("Setting socket timeout to 3.05 seconds")
        connection.settimeout(3.05)
        if config.port:
            logger.debug(
                "Attempting to bind to %s:%s", config.host, config.port
            )
        else:
            logger.debug(
                "Attempting to bind to %s with a random port", config.host
            )
        try:
            connection.bind((config.host, config.port))
            logger.debug(
                "Successfully bound to %s:%s", *connection.getsockname()
            )
            yield connection
        except Exception as e:
            yield e
        finally:
            logger.debug("Closing socket")
            connection.close()

    def _listen(self, connection):
        self.address = config.address
        logger.debug(
            "Ready to reply to incoming requests with %s", self.address
        )
        while True:
            try:
                data, addr = connection.recvfrom(1024)
                p = DNSQuery(data)
                r = p.response(self.address, p.domain)
                logger.info("DNS Request: %s -> %s", p.domain, self.address)
                connection.sendto(r, addr)
            except socket.error:
                continue

    @contextmanager
    def _resolver(self, connection):
        resolvers = []
        resolver_config = "# generated by devns\nnameserver {}\nport {}".format(
            *connection.getsockname()
        )
        try:
            if config.resolver:
                for domain in config.domains:
                    path = os.path.join("/etc", "resolver", domain)
                    with open(path, "w") as resolver:
                        logger.debug("Writing resolver config to %r", path)
                        resolver.write(resolver_config)
                    resolvers.append(path)
            yield resolvers
        except IOError as e:
            yield e
        finally:
            for resolver in resolvers:
                logger.debug("Cleaning up resolver config %r", resolver)
                os.unlink(resolver)

    @interruptable
    def _run(self, connection):
        with self._resolver(connection) as resolver:
            if isinstance(resolver, Exception):
                logger.critical(
                    "Failed trying to write resolver config: %s", resolver
                )
                return 3
            return self._listen(connection)

    def run(self):
        with self._open_socket() as connection:
            if isinstance(connection, Exception):
                logger.critical(
                    "Failed trying to open a connection: %s", connection
                )
                return 2
            return self._run(connection)


class DNSQuery:
    # DNSQuery class from
    # http://code.activestate.com/recipes/491264-mini-fake-dns-server/

    def __init__(self, data):
        self.data = data
        self.domain = ''

        tipo = (ord(data[2]) >> 3) & 15   # Opcode bits
        if tipo == 0:                     # Standard query
            ini = 12
            lon = ord(data[ini])
            while lon != 0:
                self.domain += data[ini+1:ini+lon+1]+'.'
                ini += lon + 1
                lon = ord(data[ini])

    def response(self, ip, tld):
        packet = ''
        packet += self.data[:2] + "\x81\x80"
        packet += self.data[4:6] + self.data[4:6] + '\x00\x00\x00\x00'   # Questions and Answers Counts  # noqa
        packet += self.data[12:]                                         # Original Domain Name Question  # noqa
        packet += '\xc0\x0c'                                             # Pointer to domain name  # noqa
        packet += '\x00\x01\x00\x01\x00\x00\x00\x3c\x00\x04'             # Response type, ttl and resource data length -> 4 bytes  # noqa
        packet += str.join('',map(lambda x: chr(int(x)), ip.split('.'))) # 4bytes of IP  # noqa
        return packet
